---
title: "Migrating from Solana to Stellar"
description: "A comprehensive guide for Solana developers migrating to Stellar's Soroban platform"
sidebar_label: "Solana to Stellar"
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

# Migrating from Solana to Stellar

So you're a Solana developer thinking about making the jump to Stellar? Great choice! While both platforms use Rust for smart contracts, there are some key differences that'll make your migration journey interesting.

Stellar offers several compelling advantages that might make it worth your while:

- **Cost-effective**: Transaction fees start at just 100 stroops (0.00001 XLM) per operation, with smart contracts using a resource-based fee model that scales with usage
- **Fast finality**: Stellar's ledger closes every 3-5 seconds, with transactions typically confirmed in the next ledger close
- **Familiar territory**: Rust-based development means you can leverage your existing knowledge
- **Rich ecosystem**: Built-in support for custom assets, stablecoins, and a mature network that's been running since 2014
- **Developer-friendly**: Soroban provides a clean, intuitive API that's easy to work with

## Key Architectural Differences

Before diving into the migration, let's understand the main differences:

| Aspect | Solana | Stellar (Soroban) |
| --- | --- | --- |
| **Virtual Machine** | BPF (Berkeley Packet Filter) | WebAssembly (WASM) |
| **Account Model** | Program Derived Addresses (PDAs) | Smart Contract Addresses |
| **State Storage** | Account data with Borsh serialization | Key-value storage with automatic serialization |
| **Authorization** | Manual account validation + `is_signer` checks | `require_auth()` with built-in security |
| **Cross-Contract** | Cross-Program Invocation (CPI) | `contractimport!` macro + typed clients |
| **Token Operations** | SPL Token program calls | Built-in `soroban_sdk::token::Client` |
| **Error Handling** | `ProgramError::Custom` | `#[contracterror]` with numeric codes |

## Prerequisites

Before starting your migration, make sure you have:

- **Rust** (latest stable version)
- **Stellar CLI** for contract deployment and testing
- **Basic understanding** of Solana program development

### Installation

```bash
# Install Rust (if not already installed)
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# Install Stellar CLI (choose one method)
# Option 1: Using Homebrew (macOS, Linux)
brew install stellar-cli

# Option 2: Using winget (Windows)
winget install --id Stellar.StellarCLI

# Option 3: Using cargo from source
cargo install --locked stellar-cli

# Verify installation
stellar --version
```

## Migration Process

The migration involves four main steps:

1. **Project Structure Setup**
2. **Contract Logic Conversion**
3. **State Management Migration**
4. **Testing and Deployment**

Let's go through each step with practical examples.

### Step 1: Project Structure Setup

First, create a new Soroban project:

```bash
# Create new project
cargo new my_soroban_contract
cd my_soroban_contract

# Add Soroban dependencies
cargo add soroban-sdk
cargo add --dev soroban-sdk --features testutils
```

Update your `Cargo.toml`:

```toml
[package]
name = "my_soroban_contract"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
soroban-sdk = "$VERSION"

[dev_dependencies]
soroban-sdk = { version = "$VERSION", features = ["testutils"] }

[profile.release]
opt-level = "z"
overflow-checks = true
debug = 0
strip = "symbols"
debug-assertions = false
panic = "abort"
codegen-units = 1
lto = true

[profile.release.build-override]
opt-level = 3
overflow-checks = false
```

:::note **Important**: Replace `$VERSION` with the actual latest version from [crates.io](https://crates.io/crates/soroban-sdk). As of the latest Stellar documentation, the current stable version is v20.4.0, but you should always check for the most recent release. :::

### Step 2: Contract Logic Conversion

Let's start with a simple "Hello World" example to see the differences:

<Tabs>
<TabItem value="solana" label="Solana Program">

```rust
use solana_program::{
    account_info::{next_account_info, AccountInfo},
    entrypoint,
    entrypoint::ProgramResult,
    msg,
    program_error::ProgramError,
    pubkey::Pubkey,
};

entrypoint!(process_instruction);

pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();
    let user_account = next_account_info(accounts_iter)?;

    // CRITICAL: Verify the account is a signer for authorization
    if !user_account.is_signer {
        return Err(ProgramError::MissingRequiredSignature);
    }

    // Validate account ownership
    if user_account.owner != program_id {
        return Err(ProgramError::IncorrectProgramId);
    }

    msg!("Hello, {}!", user_account.key);
    Ok(())
}
```

</TabItem>
<TabItem value="stellar" label="Stellar Contract">

```rust
use soroban_sdk::{
    contract, contractimpl, Address, Env, String,
};

#[contract]
pub struct HelloContract;

#[contractimpl]
impl HelloContract {
    pub fn hello(env: Env, user: Address) -> String {
        // CRITICAL: Verify the user authorized this transaction
        user.require_auth();

        // Return a greeting message
        String::from_slice(&env, "Hello, World!")
    }
}
```

</TabItem>
</Tabs>

**Key Differences:**

- **Authorization**: Solana requires manual `is_signer` checks, Stellar uses `require_auth()`
- **Account handling**: Solana passes accounts as parameters, Stellar uses `Address` types
- **Return types**: Solana uses `ProgramResult`, Stellar returns actual data types
- **String handling**: Stellar uses `String` type instead of `Symbol` for better consistency

### Step 3: State Management Migration

Now let's look at how to handle user data storage:

<Tabs>
<TabItem value="solana" label="Solana Program">

```rust
use solana_program::{
    account_info::{next_account_info, AccountInfo},
    entrypoint,
    entrypoint::ProgramResult,
    msg,
    program_error::ProgramError,
    pubkey::Pubkey,
    program_pack::{Pack, IsInitialized},
    sysvar::{rent::Rent, Sysvar},
};
use borsh::{BorshDeserialize, BorshSerialize};

#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub struct UserData {
    pub is_initialized: bool,
    pub name: String,
    pub balance: u64,
}

entrypoint!(process_instruction);

pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();
    let user_account = next_account_info(accounts_iter)?;
    let data_account = next_account_info(accounts_iter)?;
    let payer = next_account_info(accounts_iter)?;

    // CRITICAL: Verify the user is a signer
    if !user_account.is_signer {
        return Err(ProgramError::MissingRequiredSignature);
    }

    // Verify the payer is a signer
    if !payer.is_signer {
        return Err(ProgramError::MissingRequiredSignature);
    }

    // Validate account ownership
    if data_account.owner != program_id {
        return Err(ProgramError::IncorrectProgramId);
    }

    // Deserialize existing data or create new
    let mut user_data = if data_account.data_is_empty() {
        UserData {
            is_initialized: false,
            name: String::new(),
            balance: 0,
        }
    } else {
        UserData::try_from_slice(&data_account.data.borrow())?
    };

    // Update user data
    user_data.name = "Alice".to_string();
    user_data.balance = 100;
    user_data.is_initialized = true;

    // Serialize and save
    user_data.serialize(&mut &mut data_account.data.borrow_mut()[..])?;

    msg!("User data updated: {} with balance {}", user_data.name, user_data.balance);
    Ok(())
}
```

</TabItem>
<TabItem value="stellar" label="Stellar Contract">

```rust
use soroban_sdk::{
    contract, contractimpl, symbol_short, vec, Address, Env, String, Vec,
};

#[derive(Clone, Debug, Eq, PartialEq, soroban_sdk::serde::Serialize, soroban_sdk::serde::Deserialize)]
pub struct UserData {
    pub name: String,
    pub balance: i128,
}

#[contract]
pub struct UserDataContract;

#[contractimpl]
impl UserDataContract {
    pub fn create_user(env: Env, user: Address, name: String, balance: i128) -> UserData {
        // CRITICAL: Verify the user authorized this transaction
        user.require_auth();

        let user_data = UserData { name, balance };

        // Store user data with the user's address as the key
        env.storage().instance().set(&user, &user_data);

        user_data
    }

    pub fn get_user(env: Env, user: Address) -> Option<UserData> {
        // No authorization needed for read operations
        env.storage().instance().get(&user)
    }

    pub fn update_balance(env: Env, user: Address, new_balance: i128) -> UserData {
        // CRITICAL: Verify the user authorized this transaction
        user.require_auth();

        let mut user_data = env.storage().instance().get(&user)
            .expect("User not found");

        user_data.balance = new_balance;
        env.storage().instance().set(&user, &user_data);

        user_data
    }
}
```

</TabItem>
</Tabs>

**Key Differences:**

- **Storage**: Solana uses manual Borsh serialization, Stellar has automatic storage with `env.storage()`
- **Authorization**: Both require proper signer verification, but Stellar uses `require_auth()`
- **Data types**: Stellar uses `i128` for amounts (better for financial calculations)
- **Error handling**: Stellar uses Rust's `Result` and `Option` types

### Step 4: Cross-Contract Invocation

Here's how to call other contracts:

<Tabs>
<TabItem value="solana" label="Solana Program">

```rust
use solana_program::{
    account_info::{next_account_info, AccountInfo},
    entrypoint,
    entrypoint::ProgramResult,
    msg,
    program_error::ProgramError,
    pubkey::Pubkey,
    program::invoke,
    system_instruction,
};

entrypoint!(process_instruction);

pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();
    let user_account = next_account_info(accounts_iter)?;
    let target_account = next_account_info(accounts_iter)?;
    let system_program = next_account_info(accounts_iter)?;

    // CRITICAL: Verify the user is a signer
    if !user_account.is_signer {
        return Err(ProgramError::MissingRequiredSignature);
    }

    // Transfer SOL using system program
    let transfer_instruction = system_instruction::transfer(
        user_account.key,
        target_account.key,
        1000000, // 0.001 SOL
    );

    invoke(
        &transfer_instruction,
        &[
            user_account.clone(),
            target_account.clone(),
            system_program.clone(),
        ],
    )?;

    msg!("Transfer completed!");
    Ok(())
}
```

</TabItem>
<TabItem value="stellar" label="Stellar Contract">

```rust
use soroban_sdk::{
    contract, contractimpl, symbol_short, vec, Address, Env, String, Vec,
    token::Client as TokenClient,
};

// Import another contract for type-safe calls
contractimport!(
    file = "../other_contract/target/wasm32-unknown-unknown/release/other_contract.wasm"
);

#[contract]
pub struct TransferContract;

#[contractimpl]
impl TransferContract {
    pub fn transfer_tokens(
        env: Env,
        user: Address,
        token_address: Address,
        to: Address,
        amount: i128,
    ) -> bool {
        // CRITICAL: Verify the user authorized this transaction
        user.require_auth();

        // Use the built-in token client for transfers
        let token_client = TokenClient::new(&env, &token_address);
        token_client.transfer(&user, &to, &amount);

        true
    }

    pub fn invoke_other_contract(
        env: Env,
        user: Address,
        contract_id: Address,
        function: String,
        args: Vec<String>,
    ) -> Vec<String> {
        // CRITICAL: Verify the user authorized this transaction
        user.require_auth();

        // Call another contract using the imported client
        let other_client = OtherContractClient::new(&env, &contract_id);

        // Example: call a function on the other contract
        match function.as_str() {
            "get_data" => {
                let result = other_client.get_data(&user);
                vec![&env, result]
            }
            _ => vec![&env, String::from_slice(&env, "Unknown function")]
        }
    }
}
```

</TabItem>
</Tabs>

**Key Differences:**

- **Token transfers**: Solana requires manual CPI calls, Stellar has built-in `TokenClient`
- **Contract imports**: Solana uses raw CPI, Stellar uses `contractimport!` macro for type safety
- **Authorization**: Both require proper signer verification with `require_auth()`
- **Function calls**: Stellar provides typed clients for better developer experience

:::note **Note**: The `contractimport!` macro is the recommended high-level way to interact with other contracts. The low-level `env.invoke_contract()` function also exists for advanced use cases. :::

### Error Handling

Error handling patterns also differ significantly:

<Tabs>
<TabItem value="solana" label="Solana Program">

```rust
use solana_program::{
    program_error::ProgramError,
    msg,
};

#[derive(Debug, Clone)]
pub enum CustomError {
    InsufficientFunds,
    InvalidAccount,
    Unauthorized,
}

impl From<CustomError> for ProgramError {
    fn from(e: CustomError) -> Self {
        match e {
            CustomError::InsufficientFunds => ProgramError::Custom(1),
            CustomError::InvalidAccount => ProgramError::Custom(2),
            CustomError::Unauthorized => ProgramError::Custom(3),
        }
    }
}

pub fn process_with_errors() -> Result<(), CustomError> {
    // Your logic here
    if some_condition {
        return Err(CustomError::InsufficientFunds);
    }

    if another_condition {
        return Err(CustomError::Unauthorized);
    }

    Ok(())
}
```

</TabItem>
<TabItem value="stellar" label="Stellar Contract">

```rust
use soroban_sdk::{
    contract, contractimpl, symbol_short, vec, Address, Env, String, Vec,
};

#[contracterror]
#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]
#[repr(u32)]
pub enum CustomError {
    InsufficientFunds = 1,
    InvalidAccount = 2,
    Unauthorized = 3,
}

#[contract]
pub struct ErrorHandlingContract;

#[contractimpl]
impl ErrorHandlingContract {
    pub fn process_with_errors(env: Env, user: Address) -> Result<String, CustomError> {
        // CRITICAL: Verify the user authorized this transaction
        user.require_auth();

        // Your logic here
        if some_condition {
            return Err(CustomError::InsufficientFunds);
        }

        if another_condition {
            return Err(CustomError::Unauthorized);
        }

        Ok(String::from_slice(&env, "Success!"))
    }
}
```

</TabItem>
</Tabs>

**Key Differences:**

- **Error definition**: Solana uses manual `From` implementation, Stellar uses `#[contracterror]` macro
- **Error codes**: Stellar uses `#[repr(u32)]` for automatic error code assignment
- **Return types**: Stellar functions can return `Result<T, CustomError>` directly

## Testing Your Contract

Testing is crucial for ensuring your migration works correctly:

```rust
#[cfg(test)]
mod test {
    use super::*;
    use soroban_sdk::testutils::{Address as _,};

    #[test]
    fn test_hello() {
        let env = Env::default();
        let contract_id = env.register(HelloContract, ());
        let client = HelloContractClient::new(&env, &contract_id);

        let user = Address::random(&env);

        // Test the hello function
        let result = client.hello(&user);
        assert_eq!(result, String::from_slice(&env, "Hello, World!"));
    }

    #[test]
    fn test_user_data_flow() {
        let env = Env::default();
        let contract_id = env.register(UserDataContract, ());
        let client = UserDataContractClient::new(&env, &contract_id);

        let user = Address::random(&env);
        let name = String::from_slice(&env, "Alice");
        let balance = 100;

        // Create user
        let user_data = client.create_user(&user, &name, &balance);
        assert_eq!(user_data.name, name);
        assert_eq!(user_data.balance, balance);

        // Get user
        let retrieved_data = client.get_user(&user);
        assert_eq!(retrieved_data, Some(user_data));

        // Update balance
        let new_balance = 200;
        let updated_data = client.update_balance(&user, &new_balance);
        assert_eq!(updated_data.balance, new_balance);
    }
}
```

## Deployment

Once your contract is ready, here's how to deploy it:

### Local Development

```bash
# Start local Stellar network using Stellar CLI
stellar container start local

# Build your contract
cargo build --target wasm32-unknown-unknown --release

# Deploy to local network
stellar contract deploy \
  --wasm target/wasm32-unknown-unknown/release/my_soroban_contract.wasm \
  --source-account your_account_name \
  --network local \
  --alias my_contract
```

### Testnet Deployment

```bash
# Configure for testnet
stellar network add testnet

# Deploy to testnet
stellar contract deploy \
  --wasm target/wasm32-unknown-unknown/release/my_soroban_contract.wasm \
  --source-account your_account_name \
  --network testnet \
  --alias my_contract
```

### Mainnet Deployment

```bash
# Configure for mainnet
stellar network add mainnet

# Deploy to mainnet
stellar contract deploy \
  --wasm target/wasm32-unknown-unknown/release/my_soroban_contract.wasm \
  --source-account your_account_name \
  --network mainnet \
  --alias my_contract
```

## Common Challenges and Solutions

### 1. Authorization Patterns

**Challenge**: Understanding when and how to use `require_auth()`

**Solution**: Always call `require_auth()` on the user address for any function that modifies state or performs actions on behalf of a user.

```rust
pub fn update_user_data(env: Env, user: Address, new_data: String) -> Result<(), CustomError> {
    // This ensures only the user can call this function
    user.require_auth();

    // Now safe to update user data
    env.storage().instance().set(&user, &new_data);
    Ok(())
}
```

### 2. Storage Patterns

**Challenge**: Moving from Solana's account-based storage to Stellar's key-value storage

**Solution**: Use Stellar's storage abstraction with proper key management:

```rust
// Store data with user address as key
env.storage().instance().set(&user, &user_data);

// Retrieve data
let user_data: Option<UserData> = env.storage().instance().get(&user);
```

### 3. Cross-Contract Calls

**Challenge**: Converting from Solana CPI to Stellar contract calls

**Solution**: Use the `contractimport!` macro for type-safe interactions:

```rust
contractimport!(
    file = "../token_contract/target/wasm32-unknown-unknown/release/token_contract.wasm"
);

// Now you have a typed client
let token_client = TokenContractClient::new(&env, &token_address);
token_client.transfer(&from, &to, &amount);
```

## Best Practices

1. **Always use `require_auth()`** for functions that modify state
2. **Use `String` instead of `Symbol`** for better consistency with modern Stellar examples
3. **Leverage `contractimport!`** for type-safe cross-contract calls
4. **Use built-in `TokenClient`** for token operations instead of manual contract calls
5. **Test thoroughly** with both unit and integration tests
6. **Follow Stellar's error handling patterns** with `#[contracterror]`

## Resources

You're not alone in this journey! Here are some resources to help you along the way:

- **Soroban Documentation**: [Smart Contracts Overview](../../../build/smart-contracts/overview)
- **Getting Started**: [Setup Guide](../../../build/smart-contracts/getting-started/setup)
- **Example Contracts**: [Contract Examples](../../../build/smart-contracts/example-contracts)
- **Stellar CLI**: [CLI Documentation](../../../tools/cli)
- **Community**: Join the [Stellar Developer Discord](https://discord.gg/stellardev)

## Next Steps

Now that you have a solid foundation, consider exploring:

- **Advanced Soroban features** like custom types and complex storage patterns
- **Integration with Stellar's built-in features** like asset management
- **Performance optimization** techniques specific to WebAssembly
- **Security best practices** for production deployments

Remember, migration is a journey, not a destination. Take your time, test thoroughly, and don't hesitate to reach out to the Stellar community for help. Welcome to the ecosystem! 🚀

---
sidebar_position: 20
title: Solana to Stellar Migration Guide
description: Migrate your smart contract code from Solana to Stellar's Soroban platform
---

# Migrating from Solana to Stellar

If you're a Solana developer looking to explore Stellar's Soroban smart contracts platform, you're in the right place! This guide will walk you through the key differences between the two platforms and show you how to port your Solana programs to Stellar.

The good news? Both platforms use Rust, so you already have a solid foundation. The migration process involves understanding some architectural differences and adapting your code to use Stellar's patterns instead of Solana's.

## Why Consider Stellar?

Stellar offers several compelling advantages that might make it worth your while:

- **Cost-effective**: Transaction fees start at just 100 stroops (0.00001 XLM) per operation, with smart contracts using a resource-based fee model that scales with usage
- **Fast and reliable**: Ledgers close every 3-5 seconds, providing quick transaction confirmation
- **Familiar territory**: Rust-based development means you can leverage your existing knowledge
- **Rich ecosystem**: Built-in support for custom assets, stablecoins, and a mature network that's been running since 2014
- **Developer-friendly**: Soroban provides a clean, intuitive API that's easy to work with

## Understanding the Differences

Before diving into the migration, let's look at how Solana and Stellar differ in their approach to smart contracts.

### Architecture Overview

| Aspect | Solana | Stellar (Soroban) |
| --- | --- | --- |
| **Programming Model** | Account-based with Program Derived Addresses (PDAs) | Account-based with smart contract addresses |
| **Language** | Rust (with Solana-specific macros) | Rust (with Soroban SDK) |
| **Virtual Machine** | Solana Runtime (custom) | WebAssembly (WASM) |
| **State Management** | Account data with size limits | Persistent storage with key-value pairs |
| **Cross-Program Invocation** | `invoke()` and `invoke_signed()` | `env.invoke_contract()` |
| **Error Handling** | Custom error types | Rust Result types |

### Smart Contract Structure Comparison

Let's look at how the basic structure differs between the two platforms.

#### Solana Program Structure

```rust
use solana_program::{
    account_info::{next_account_info, AccountInfo},
    entrypoint,
    entrypoint::ProgramResult,
    msg,
    program_error::ProgramError,
    pubkey::Pubkey,
};

entrypoint!(process);

pub fn process(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    // Program logic here
    Ok(())
}
```

#### Stellar Soroban Contract Structure

```rust
use soroban_sdk::{
    contract, contractimpl, symbol_short, vec, Address, Env, Symbol, Vec,
};

#[contract]
pub struct HelloContract;

#[contractimpl]
impl HelloContract {
    pub fn hello(env: Env, to: Symbol) -> Vec<Symbol> {
        vec![&env, symbol_short!("Hello"), to]
    }
}
```

Notice how much cleaner the Soroban version is? No need to handle accounts manually or parse instruction data - the framework handles that for you.

## Setting Up Your Development Environment

### Prerequisites

You'll need the same tools you're already using for Solana development:

1. **Rust**: Version 1.70 or higher (same requirement as Solana)
2. **Stellar CLI**: For building, testing, and deploying contracts
3. **IDE**: VS Code with Rust extensions works perfectly

### Installing the Stellar CLI

The Stellar CLI is your gateway to the Soroban ecosystem. Here are the installation options:

```bash
# Install Rust (if you haven't already)
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# Install Stellar CLI - choose your preferred method:
# Option 1: Homebrew (macOS, Linux)
brew install stellar-cli

# Option 2: Windows Package Manager
winget install --id Stellar.StellarCLI

# Option 3: From source using Cargo
cargo install --locked stellar-cli

# Verify the installation
stellar --version
```

### Project Setup

Creating a new Soroban project is straightforward:

```bash
# Create a new project
cargo new my-soroban-contract
cd my-soroban-contract

# Add Soroban dependencies to Cargo.toml
```

## Migrating Your First Contract

Let's walk through the migration process step by step. We'll start with a simple example and gradually build up to more complex patterns.

### Step 1: Update Dependencies

First, you'll need to replace your Solana dependencies with Soroban equivalents. Here's what your `Cargo.toml` should look like:

```toml
[package]
name = "my-soroban-contract"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
soroban-sdk = "$VERSION"

[dev_dependencies]
soroban-sdk = { version = "$VERSION", features = ["testutils"] }
```

:::note **Important**: Replace `$VERSION` with the actual latest version from [crates.io](https://crates.io/crates/soroban-sdk). As of the latest Stellar documentation, the current stable version is v20.4.0, but you should always check for the most recent release. :::

The release profile configuration is crucial for keeping your contract size under the 64KB limit:

```toml
[profile.release]
opt-level = "z"
overflow-checks = true
debug = 0
strip = "symbols"
debug-assertions = false
panic = "abort"
codegen-units = 1
lto = true

[profile.release.build-override]
opt-level = 3
incremental = false
codegen-units = 1
```

### Step 2: Convert Program Entry Point

The biggest change you'll notice is how functions are defined and called.

**Before (Solana):**

```rust
use solana_program::{
    account_info::{next_account_info, AccountInfo},
    entrypoint,
    entrypoint::ProgramResult,
    msg,
    program_error::ProgramError,
    pubkey::Pubkey,
};

entrypoint!(process);

pub fn process(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();
    let payer = next_account_info(accounts_iter)?;

    msg!("Hello from Solana!");
    Ok(())
}
```

**After (Stellar):**

```rust
use soroban_sdk::{
    contract, contractimpl, symbol_short, vec, Address, Env, Symbol, Vec,
};

#[contract]
pub struct HelloContract;

#[contractimpl]
impl HelloContract {
    pub fn hello(env: Env, to: Symbol) -> Vec<Symbol> {
        vec![&env, symbol_short!("Hello"), to]
    }
}
```

The Soroban version is much more intuitive - just define your struct, implement the functions you want, and the framework handles the rest.

### Step 3: Convert Account Handling

Solana requires you to manually manage accounts and validate ownership. Soroban simplifies this significantly.

**Before (Solana):**

```rust
pub fn process(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();
    let user_account = next_account_info(accounts_iter)?;
    let data_account = next_account_info(accounts_iter)?;

    // Validate account ownership
    if user_account.owner != program_id {
        return Err(ProgramError::IncorrectProgramId);
    }

    // Access account data
    let mut data = data_account.data.borrow_mut();
    // ... process data
    Ok(())
}
```

**After (Stellar):**

```rust
use soroban_sdk::{
    contract, contractimpl, symbol_short, vec, Address, Env, Symbol, Vec,
};

#[contract]
pub struct DataContract;

#[contractimpl]
impl DataContract {
    pub fn store_data(env: Env, user: Address, data: Symbol) {
        // Store data with user as key
        env.storage().instance().set(&user, &data);
    }

    pub fn get_data(env: Env, user: Address) -> Option<Symbol> {
        env.storage().instance().get(&user)
    }
}
```

No more manual account validation or data borrowing - Soroban handles the storage abstraction for you.

### Step 4: Convert State Management

State management is one of the biggest differences. Solana uses fixed-size accounts, while Soroban provides flexible key-value storage.

**Before (Solana):**

```rust
#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub struct UserData {
    pub name: String,
    pub balance: u64,
    pub is_active: bool,
}

pub fn process(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();
    let user_data_account = next_account_info(accounts_iter)?;

    // Deserialize data
    let mut user_data = UserData::try_from_slice(&user_data_account.data.borrow())?;

    // Update data
    user_data.balance += 100;

    // Serialize and save
    user_data.serialize(&mut &mut user_data_account.data.borrow_mut()[..])?;
    Ok(())
}
```

**After (Stellar):**

```rust
use soroban_sdk::{
    contract, contractimpl, symbol_short, vec, Address, Env, Symbol, Vec,
};

#[derive(Clone, Debug, Eq, PartialEq, soroban_sdk::serde::Serialize, soroban_sdk::serde::Deserialize)]
pub struct UserData {
    pub name: Symbol,
    pub balance: u64,
    pub is_active: bool,
}

#[contract]
pub struct UserDataContract;

#[contractimpl]
impl UserDataContract {
    pub fn create_user(env: Env, user: Address, name: Symbol) {
        let user_data = UserData {
            name,
            balance: 0,
            is_active: true,
        };
        env.storage().instance().set(&user, &user_data);
    }

    pub fn update_balance(env: Env, user: Address, amount: u64) {
        if let Some(mut user_data) = env.storage().instance().get(&user) {
            user_data.balance += amount;
            env.storage().instance().set(&user, &user_data);
        }
    }

    pub fn get_user_data(env: Env, user: Address) -> Option<UserData> {
        env.storage().instance().get(&user)
    }
}
```

The Soroban version is much cleaner - no manual serialization/deserialization, and the storage system automatically handles the data lifecycle.

## Advanced Migration Patterns

Now let's look at some more complex patterns you might encounter when migrating larger contracts.

### Cross-Contract Invocation

Cross-contract calls work differently between the two platforms.

**Before (Solana):**

```rust
use solana_program::{
    program::invoke,
    system_instruction,
};

pub fn process(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();
    let payer = next_account_info(accounts_iter)?;
    let recipient = next_account_info(accounts_iter)?;
    let system_program = next_account_info(accounts_iter)?;

    // Transfer SOL
    let transfer_instruction = system_instruction::transfer(
        &payer.key,
        &recipient.key,
        1000000, // 0.001 SOL
    );

    invoke(
        &transfer_instruction,
        &[payer.clone(), recipient.clone(), system_program.clone()],
    )?;

    Ok(())
}
```

**After (Stellar):**

```rust
use soroban_sdk::{
    contract, contractimpl, symbol_short, vec, Address, Env, Symbol, Vec,
};

#[contract]
pub struct TransferContract;

#[contractimpl]
impl TransferContract {
    pub fn invoke_other_contract(env: Env, contract_id: Address, function: Symbol, args: Vec<Symbol>) {
        // Invoke another contract
        let _: Vec<Symbol> = env.invoke_contract(&contract_id, &function, &args);
    }
}
```

:::note **Important**: Stellar's `env.invoke_contract()` is the low-level way to call other contracts. For better type safety and developer experience, you can also use the `contractimport!` macro to generate typed clients for contract interactions. :::

### Error Handling

Error handling is much more straightforward in Soroban thanks to Rust's built-in Result types.

**Before (Solana):**

```rust
use solana_program::program_error::ProgramError;

#[derive(Debug)]
pub enum CustomError {
    InsufficientFunds,
    InvalidAccount,
    Unauthorized,
}

impl From<CustomError> for ProgramError {
    fn from(e: CustomError) -> Self {
        ProgramError::Custom(e as u32)
    }
}

pub fn process(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();
    let user_account = next_account_info(accounts_iter)?;

    if user_account.lamports() < 1000000 {
        return Err(CustomError::InsufficientFunds.into());
    }

    Ok(())
}
```

**After (Stellar):**

```rust
use soroban_sdk::{
    contract, contractimpl, symbol_short, vec, Address, Env, Symbol, Vec,
};

#[contracterror]
#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]
#[repr(u32)]
pub enum CustomError {
    InsufficientFunds = 1,
    InvalidAccount = 2,
    Unauthorized = 3,
}

#[contract]
pub struct ErrorHandlingContract;

#[contractimpl]
impl ErrorHandlingContract {
    pub fn check_balance(env: Env, user: Address) -> Result<(), CustomError> {
        // Check user balance (this is a simplified example)
        if user.as_ref().len() == 0 {
            return Err(CustomError::InvalidAccount);
        }

        // Your logic here
        Ok(())
    }
}
```

The `#[contracterror]` macro automatically handles the conversion to Soroban's error system, making error handling much cleaner.

## Testing Your Migrated Contract

Testing is crucial when migrating contracts. Soroban provides excellent testing utilities that make it easy to verify your code works correctly.

### Unit Testing

Here's how you can test your migrated contract:

```rust
#[cfg(test)]
mod test {
    use super::*;
    use soroban_sdk::{
        symbol_short, vec, Address, Env, Symbol, Vec,
        testutils::{Address as _,},
    };

    #[test]
    fn test_hello() {
        let env = Env::default();
        let contract_id = env.register(HelloContract, ());
        let client = HelloContractClient::new(&env, &contract_id);

        let to = symbol_short!("Dev");
        let result = client.hello(&to);

        assert_eq!(result, vec![&env, symbol_short!("Hello"), to]);
    }
}
```

### Integration Testing

For more complex scenarios involving multiple contracts:

```rust
#[cfg(test)]
mod test {
    use super::*;
    use soroban_sdk::{
        symbol_short, vec, Address, Env, Symbol, Vec,
        testutils::{Address as _,},
    };

    #[test]
    fn test_user_data_flow() {
        let env = Env::default();
        let contract_id = env.register(UserDataContract, ());
        let client = UserDataContractClient::new(&env, &contract_id);

        let user = Address::random(&env);
        let name = symbol_short!("Alice");

        // Create user
        client.create_user(&user, &name);

        // Update balance
        client.update_balance(&user, &100);

        // Get user data
        let user_data = client.get_user_data(&user).unwrap();
        assert_eq!(user_data.balance, 100);
        assert_eq!(user_data.name, name);
    }
}
```

The testing environment is very similar to what you're used to with Solana, but with Soroban's testing utilities.

## Deployment and Network Configuration

Once you're satisfied with your migrated contract, it's time to deploy it to the network.

### Local Development

Start with local development to test your contract:

```bash
# Start local Stellar network using Stellar CLI
stellar container start local

# Build your contract
cargo build --target wasm32-unknown-unknown --release

# Deploy to local network
stellar contract deploy \
  --wasm target/wasm32-unknown-unknown/release/my_soroban_contract.wasm \
  --source-account your_account_name \
  --network local \
  --alias my_contract
```

### Testnet Deployment

When you're ready to test on a public network:

```bash
# Configure for testnet
stellar network add testnet

# Deploy to testnet
stellar contract deploy \
  --wasm target/wasm32-unknown-unknown/release/my_soroban_contract.wasm \
  --source-account your_account_name \
  --network testnet \
  --alias my_contract
```

### Mainnet Deployment

For production deployment:

```bash
# Configure for mainnet
stellar network add mainnet

# Deploy to mainnet
stellar contract deploy \
  --wasm target/wasm32-unknown-unknown/release/my_soroban_contract.wasm \
  --source-account your_account_name \
  --network mainnet \
  --alias my_contract
```

## Common Migration Challenges and Solutions

As you migrate more complex contracts, you'll likely encounter some common challenges. Here's how to handle them:

### 1. Account Size Limitations

**Challenge**: Solana accounts have fixed sizes, while Stellar uses dynamic storage.

**Solution**: Use Stellar's key-value storage system with appropriate data structures. You can store as much data as you need without worrying about account size limits.

### 2. Program Derived Addresses (PDAs)

**Challenge**: Solana's PDA system for deterministic addresses.

**Solution**: Use Stellar's address generation and storage mapping. You can create deterministic addresses using the same principles, but with more flexibility.

### 3. Cross-Program Invocation

**Challenge**: Solana's complex CPI system.

**Solution**: Stellar's simpler `env.invoke_contract()` function. The `contractimport!` macro provides even better type safety for cross-contract calls.

### 4. Error Handling

**Challenge**: Solana's custom error system.

**Solution**: Use Rust's built-in Result types with the `#[contracterror]` macro for automatic error conversion.

## Best Practices for Migration

Here are some tips to make your migration smoother:

1. **Start Simple**: Begin with basic contracts before tackling complex ones. Get comfortable with the new patterns first.

2. **Test Thoroughly**: Use Stellar's local testing environment extensively. The testing utilities are excellent and will catch many issues early.

3. **Leverage Rust**: Both platforms use Rust, so focus on platform-specific differences rather than learning a new language.

4. **Use Soroban SDK**: Familiarize yourself with Stellar's SDK patterns. The documentation is comprehensive and the examples are helpful.

5. **Incremental Migration**: Port contracts one at a time, testing each thoroughly before moving to the next.

6. **Understand Storage**: Take time to understand how Soroban's storage system works - it's quite different from Solana's account model.

## Resources and Next Steps

You're not alone in this journey! Here are some resources to help you along the way:

- **Soroban Documentation**: [Smart Contracts Overview](../../../build/smart-contracts/overview)
- **Getting Started**: [Setup Guide](../../../build/smart-contracts/getting-started/setup)
- **Example Contracts**: [Contract Examples](../../../build/smart-contracts/example-contracts)
- **Stellar CLI**: [CLI Documentation](../../../tools/cli)
- **Community**: Join the [Stellar Developer Discord](https://discord.gg/stellardev)

## Summary

Migrating from Solana to Stellar involves understanding the architectural differences while leveraging your existing Rust knowledge. The key is to:

1. **Understand the differences** in account models, state management, and cross-contract communication
2. **Adapt your code** to use Stellar's Soroban SDK patterns
3. **Test thoroughly** using Stellar's local development environment
4. **Deploy incrementally** to ensure stability

With this guide and the resources provided, you should be well-equipped to successfully migrate your Solana programs to Stellar's Soroban platform. The Rust foundation you already have will make this transition much smoother than starting from scratch with a different language.

Remember, migration is a process. Take your time, test everything thoroughly, and don't hesitate to reach out to the community if you run into issues. Happy coding!
